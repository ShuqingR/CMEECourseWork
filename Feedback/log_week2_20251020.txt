======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Shuqing Ren

Processing week 2

Your current Git repo size is about 1.45 MiB on disk

Found directories: .git, week1, week2, Feedback
Found files: README.md

Processing week 2: week2

Found 7 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: lc2.py

Contents:

**********
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

rainfall_over100 = [pair                    # stored object
                    for pair in rainfall    # loop over the outer tuple
                    if pair[1] > 100]       # selecting condition

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

month_under50 = [pair[0]
                 for pair in rainfall
                 if pair[1] < 50]

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

over100_cl = [] 
for pair in rainfall:
    if pair[1] > 100:
        over100_cl.append(pair)
        
under50_cl = []
for pair in rainfall:
    if pair[1] < 50:
        under50_cl.append(pair[0])

# A good example output is:
#
# Step #1:
# Months and rainfall values when the amount of rain was greater than 100mm:
# [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
# ... etc.


**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: dictionary.py

Contents:

**********
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a python script to populate a dictionary called taxa_dic derived from
# taxa so that it maps order names to sets of taxa and prints it to screen.
# 
# An example output is:
#  
# 'Chiroptera' : set(['Myotis lucifugus']) ... etc. 
# OR, 
# 'Chiroptera': {'Myotis  lucifugus'} ... etc

#### Your solution here #### 

order = set([]) 
for sp in taxa:
    order.add(sp[1])
order = list(order)             # get a list of unique orders

taxa_dic = {}
for o in order:                 # loop over the unique order list
    set_sp = set()              # empty species set
    for sp in taxa:             # loop over each species
        if sp[1] == o:          # check if th order matches
            set_sp.add(sp[0])   # add to set if matched
    taxa_dic[o] = set_sp        # pair order with species set
print(taxa_dic)


# Now write a list comprehension that does the same (including the printing after the dictionary has been created)  
 
#### Your solution here #### 

print({o:                                       # dictionary key
       {sp[0] for sp in taxa if sp[1] == o}     # paring species names
       for o in list({sp[1] for sp in taxa})    # designation of key
      })                                        # just print, no saved dictionary?
**********

Output (first 500 chars):

**********
{'Carnivora': {'Lyacon pictus', 'Canis lupus', 'Arctocephalus gazella'}, 'Rodentia': {'Gerbillus henleyi', 'Mus domesticus', 'Cleithrionomys rutilus', 'Peromyscus crinitus'}, 'Chiroptera': {'Myotis lucifugus'}, 'Afrosoricida': {'Microgale dobsoni', 'Microgale talazaci'}}
{'Carnivora': {'Lyacon pictus', 'Canis lupus', 'Arctocephalus gazella'}, 'Rodentia': {'Gerbillus henleyi', 'Mus domesticus', 'Cleithrionomys rutilus', 'Peromyscus crinitus'}, 'Chiroptera': {'Myotis lucifugus'}, 'Afrosoricida': {
**********
No errors.
======================================================================
Script: cfexercises1.py

Contents:

**********
#!/user/bin/env python3

"""2/4 of CMEE week2 coursework (control flow)"""
__author__ = "Shuqing Ren"
__version__ = "0.0.1"

import sys

def foo_1(x=9):
    """Find the square root of input"""
    sqr_x = x ** 0.5    # (= x^0.5)
    return f"The square root of {x} is {sqr_x}."

def foo_2(x=7, y=0):
    """Compare the value of a pair of numbers."""
    if x > y:
        return f"{x} is larger than {y}."
    elif x == y:
        return f"{x} is equal to {y}."
    return f"{y}is larger than {x}."

def foo_3(x=5, y=3, z=8):
    """Sort a list from the smallest to largest"""
    if x > y:
        x, y = y, x
    if x > z:
        x, z = z, x
    if y > z:
        y, z = z, y
    a_list = [x, y, z]
    return f"From the smallest to largest: {a_list}"

def foo_4(x=2):
    """Calculate the factorial of x."""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return f"The factorial of {x} is {result}."

def foo_5(x=6): # a recursive function that calculates the factorial of x
    """Recursively calculate the factorial of x."""
    if x == 1 or x == 0:   # modify to also return result for 0
        return 1
    return x * foo_5(x - 1)
# !: can't find a way to print final the result, no return message for this
     
def foo_6(x=4):  # Calculate the factorial of x in a different way
    """Calculate the factorial of x without if statement."""
    facto = 1
    x_loop = x   # copy x to another variable for looping control, so x remains unchanged
    while x_loop >= 1:
        facto = facto * x_loop
        x_loop = x_loop - 1
    return f"The factorial of {x} is {facto}."

def main(argv):
    print(foo_1())
    print(foo_2())
    print(foo_3())
    print(foo_4())
    print(f"The factorial of 6 is {foo_5()}.")
    print(foo_6())
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
The square root of 9 is 3.0.
7 is larger than 0.
From the smallest to largest: [3, 5, 8]
The factorial of 2 is 2.
The factorial of 6 is 720.
The factorial of 4 is 24.

**********
No errors.
======================================================================
Script: lc1.py

Contents:

**********
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

birds_latin = [species[0]                    # select the wanted element of inner tuple
               for species in birds]         # loop over the outer tuple (species)

birds_common = [species[1]
                for species in birds]

birds_mass = [species[2]
              for species in birds]

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

latin_cl = []                   # empty list for storage
for species in birds:           # loop over the outer tuple
    latin_cl.append(species[0]) # append the wanted element of inner tuple

common_cl = []
for species in birds:
    common_cl.append(species[1])

mass_cl = []
for species in birds:
    mass_cl.append(species[2])

# A nice example out out is:
# Step #1:
# Latin names:
# ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
# ... etc.
 
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: oaks_debugme.py

Contents:

**********
import csv
import sys

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus'.
    
    >>> is_an_oak('Fagus sylvatica')
    False
    
    >>> is_an_oak('Quercus robur')
    True

    >>> is_an_oak('Quercuss')
    False
    
    """
    # Modify to if loop to chacke the exact match.
    if name.lower() == 'quercus':  # fixed typo, original: quercs
        return True
    else:
        return False

def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)    # add exit
**********

Output (first 500 chars):

**********
['Genus', ' species']
The genus is: 
Genus

['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********
No errors.
======================================================================
Script: tuple.py

Contents:

**********
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by
# species 
# 
# A nice example output is:
# 
# Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
# ... etc.

for species in birds:                       # loop over by species(the outer tuple)
    print("Latin name: " + species[0] +     # print elements one by one
          "; Common name: " + species[1] + 
          "; Mass: " + str(species[2]))     # only same type can be concatenated

**********

Output (first 500 chars):

**********
Latin name: Passerculus sandwichensis; Common name: Savannah sparrow; Mass: 18.7
Latin name: Delichon urbica; Common name: House martin; Mass: 19
Latin name: Junco phaeonotus; Common name: Yellow-eyed junco; Mass: 19.5
Latin name: Junco hyemalis; Common name: Dark-eyed junco; Mass: 19.6
Latin name: Tachycineata bicolor; Common name: Tree swallow; Mass: 20.2

**********
No errors.
======================================================================
Script: align_seqs.py

Contents:

**********
#!/user/bin/env python3

"""3/4 of CMEE week2 coursework (sequence alignment)"""
__author__ = "Shuqing Ren"
__version__ = "0.0.1"

import sys

# extract sequences from external file to a list
seq = []
with open("../data/SampleSeq.fasta","r") as s:
    for line in s:
        if line[0] != ">":
            seq.append(line.strip())

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
l1 = len(seq[0])
l2 = len(seq[1])
if l1 >= l2:
    s1 = seq[0]
    s2 = seq[1]
else:
    s1 = seq[1]
    s2 = seq[0]
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                score = score + 1
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

# save the output to a text file
with open("../results/aligned_seqs.txt", "w") as out:
    print(my_best_align, file = out)
    print(s1, file = out)
    print("Best score:", my_best_score, file = out)

def main(argv):
    print("Run as main")
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
Run as main

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 7
Scripts successful: 7
Scripts with errors: 0
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

