======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Shuqing Ren

Processing all weeks found in repository

Your current Git repo size is about 1.45 MiB on disk

Found directories: .git, week1, week4, week2, Feedback, week3
Found files: .gitignore, README.md

Processing all weeks: week1, week4, week2, week3

Found 50 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/bash
# Disc: covert file format for assigned temperature data, comma to space seperated values

for t in ../data/18*.csv;
    do 
        if [ -e "$t" ] # check if csv temperature files exists
        then # if input exists, run the code
            echo "Creating a space seperated version of $t ..."
            cat "$t" | tr "," " " >> "../results/$(basename "$t" .csv).ssv" 
            # convert the commas to spaces, save as a new file in ../results
            echo "Done!"
        else # if input missing, print reminder
            echo "No input file assigned"
        fi
    done

exit



**********

Output (first 500 chars):

**********
Creating a space seperated version of ../data/1800.csv ...
Done!
Creating a space seperated version of ../data/1801.csv ...
Done!
Creating a space seperated version of ../data/1802.csv ...
Done!
Creating a space seperated version of ../data/1803.csv ...
Done!

**********
No errors.
======================================================================
Script: MyExamplescript.sh

Contents:

**********
#!/bin/sh

MSG1="Hello"
MSG2=$USER
echo "$MSG1 $MSG2"
echo "Hello $USER"
echo
**********

Output (first 500 chars):

**********
Hello mhasoba
Hello mhasoba


**********
No errors.
======================================================================
Script: test_tiff2png.sh

Contents:

**********
#!/bin/bash

for f in ../data/*.tif; 
    do  
        echo "Converting ${f}"; 
        convert "$f"  "../results/$(basename "$f" .tif).png"; 
    done

# ditect absence of arguent and print reminder
**********

Output (first 500 chars):

**********
Converting ../data/TIFFexample.tif

**********
No errors.
======================================================================
Script: test.sh

Contents:

**********
# test the script
echo -e "test \t\t test" >> ../sandbox/test.txt

**********

Output (first 500 chars):

**********

**********
Errors:
**********
test.sh: line 2: ../sandbox/test.txt: No such file or directory

**********
======================================================================
Script: tiff2png.sh

Contents:

**********
#!/bin/bash

if [ -e "$1" ] # check input exist
then # if input exist, run the code
    echo "Converting $1 to ../results";
    convert "$1" "../results/$(basename "$1" .tif).png"
    # convert and redirect output to results folder
else # if no input, print reminder
    echo "No valid TIF file given"
fi        


**********

Output (first 500 chars):

**********
No valid TIF file given

**********
No errors.
======================================================================
Script: boilerplate.sh

Contents:

**********
#!/bin/sh
# Author: Shuqing Ren sr1822@ic.ac.uk
# Script: boilerplate.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Oct 2025

echo -e "This is a shell script for" 
read    # assign a variable by reading user input
echo " ! "

#exit
**********

Output (first 500 chars):

**********
This is a shell script for
 ! 

**********
No errors.
======================================================================
Script: ConcatenateTwoFiles.sh

Contents:

**********
#!/bin/bash

if [ -e "$1" ] # check if $1 exist?
then # if $1 exist
    if [ -e "$2" ] # check if $2 exist?
    then # if $2 exist
        if [ -e "$3" ] # check if $3 exist?
        then # if $3 exist, run the code
            cat $1 > $3
            cat $2 >> $3
            echo "Merged File is"
            echo $3
        else # if no $3, print reminder
            echo "Failed merge, no output file."
        fi
    else # if no $2, print reminder
        echo "Failed merge, only one file input."
    fi
else # if no $1, print reminder
    echo "Failed merge, no input files."
fi
**********

Output (first 500 chars):

**********
Failed merge, no input files.

**********
No errors.
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!bin/sh
# Author: Shuqing Ren sr1822@ic.ac.uk
# Script: tabtocsv.sh
# Description: substitute the tab in the files with commas
#
# Saves the output into a .csv file
# Arguments: 1 -> tab delimited file
# Date: Oct 2025

if [ -e "$1" ] # check if input file exists
then # if input exists, run the code
    echo "Creating a comma delimited version of $1 ..."
    cat $1 | tr -s "\t" "," >> $1.csv
    echo "Done!"
else # if input missing, print reminder
    echo "No input file assigned"
fi

exit

**********

Output (first 500 chars):

**********
No input file assigned

**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
#!/bin/sh

## Illustrates the use of variables 

# Special variables

echo "This script was called with $# parameters"
echo "The script's name is $0"
echo "The arguments are $@"
echo "The first argument is $1"
echo "The second argument is $2"

# Assigned Variables; Explicit declaration:
MY_VAR='some string' 
echo 'the current value of the variable is:' $MY_VAR
echo
echo 'Please enter a new string'
read MY_VAR
echo
echo 'the current value of the variable is:' $MY_VAR
echo

## Assigned Variables; Reading (multiple values) from user input:
echo 'Enter two numbers separated by space(s)'
read a b
echo
echo 'you entered' $a 'and' $b '; Their sum is:'

## Assigned Variables; Command substitution
MY_SUM=$(expr $a + $b)
echo $MY_SUM
**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh
The arguments are 
The first argument is 
The second argument is 
the current value of the variable is: some string

Please enter a new string

the current value of the variable is:

Enter two numbers separated by space(s)

you entered and ; Their sum is:


**********
Errors:
**********
expr: syntax error: missing argument after ‘+’

**********
======================================================================
Script: CountLines.sh

Contents:

**********
#!/bin/bash

if [ -e "$1" ] # check if $1 exist?
then # if input file exist, run the code
    NumLines=`wc -l < $1`
    echo "The file $1 has $NumLines lines"
else # if no input file, print reminder
    echo " No input file found"
fi
**********

Output (first 500 chars):

**********
 No input file found

**********
No errors.
======================================================================
Script: profileme2.py

Contents:

**********
def my_squares(iters):
    out = [i ** 2 for i in range(iters)]
    return out

def my_join(iters, string):
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")
**********

Output (first 500 chars):

**********
10000000 My string

**********
No errors.
======================================================================
Script: profileme.py

Contents:

**********
def my_squares(iters):
    out = []
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    out = ''
    for i in range(iters):
        out += string.join(", ")
    return out

def run_my_funcs(x,y):
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")
**********

Output (first 500 chars):

**********
10000000 My string

**********
No errors.
======================================================================
Script: timeitem.py

Contents:

**********
##############################################################################
# loops vs. list comprehensions: which is faster?
##############################################################################

iters = 1000000

import timeit

from profileme import my_squares as my_squares_loops

from profileme2 import my_squares as my_squares_lc

# test commands: %timeit my_squares_loops(iters)
#                %timeit my_squares_lc(iters)

##############################################################################
# loops vs. the join method for strings: which is faster?
##############################################################################

mystring = "my string"

from profileme import my_join as my_join_join

from profileme2 import my_join as my_join

# test commands: %timeit (my_join_join(iters, mystring))
#                %timeit (my_join(iters, mystring))

##############################################################################
# Another way to time functions
##############################################################################

import time
start = time.time()
my_squares_loops(iters)
print(f"my_squares_loops takes {time.time() - start} s to run.")

start = time.time()
my_squares_lc(iters)
print(f"my_squares_lc takes {time.time() - start} s to run.")

# Note:
# time captures a single run (change slightly each time)
# timeit gives an average of several runs 
**********

Output (first 500 chars):

**********
10000000 My string
10000000 My string
my_squares_loops takes 0.03974294662475586 s to run.
my_squares_lc takes 0.03618335723876953 s to run.

**********
No errors.
======================================================================
Script: MyExampleScript.py

Contents:

**********

def foo(x):
    x *= x # same as x = x*x
    print(x)

foo(2)
**********

Output (first 500 chars):

**********
4

**********
No errors.
======================================================================
Script: lc2.py

Contents:

**********
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

rainfall_over100 = [pair                    # stored object
                    for pair in rainfall    # loop over the outer tuple
                    if pair[1] > 100]       # selecting condition

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

month_under50 = [pair[0]
                 for pair in rainfall
                 if pair[1] < 50]

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

over100_cl = [] 
for pair in rainfall:
    if pair[1] > 100:
        over100_cl.append(pair)
        
under50_cl = []
for pair in rainfall:
    if pair[1] < 50:
        under50_cl.append(pair[0])

# A good example output is:
#
# Step #1:
# Months and rainfall values when the amount of rain was greater than 100mm:
# [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
# ... etc.


**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: oaks.py

Contents:

**********
## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********

Output (first 500 chars):

**********
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********
No errors.
======================================================================
Script: dictionary.py

Contents:

**********
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a python script to populate a dictionary called taxa_dic derived from
# taxa so that it maps order names to sets of taxa and prints it to screen.
# 
# An example output is:
#  
# 'Chiroptera' : set(['Myotis lucifugus']) ... etc. 
# OR, 
# 'Chiroptera': {'Myotis  lucifugus'} ... etc

#### Your solution here #### 

order = set([]) 
for sp in taxa:
    order.add(sp[1])
order = list(order)             # get a list of unique orders

taxa_dic = {}
for o in order:                 # loop over the unique order list
    set_sp = set()              # empty species set
    for sp in taxa:             # loop over each species
        if sp[1] == o:          # check if th order matches
            set_sp.add(sp[0])   # add to set if matched
    taxa_dic[o] = set_sp        # pair order with species set
print(taxa_dic)


# Now write a list comprehension that does the same (including the printing after the dictionary has been created)  
 
#### Your solution here #### 

print({o:                                       # dictionary key
       {sp[0] for sp in taxa if sp[1] == o}     # paring species names
       for o in list({sp[1] for sp in taxa})    # designation of key
      })                                        # just print, no saved dictionary?
**********

Output (first 500 chars):

**********
{'Rodentia': {'Gerbillus henleyi', 'Mus domesticus', 'Cleithrionomys rutilus', 'Peromyscus crinitus'}, 'Chiroptera': {'Myotis lucifugus'}, 'Carnivora': {'Canis lupus', 'Lyacon pictus', 'Arctocephalus gazella'}, 'Afrosoricida': {'Microgale dobsoni', 'Microgale talazaci'}}
{'Rodentia': {'Gerbillus henleyi', 'Mus domesticus', 'Cleithrionomys rutilus', 'Peromyscus crinitus'}, 'Chiroptera': {'Myotis lucifugus'}, 'Carnivora': {'Canis lupus', 'Lyacon pictus', 'Arctocephalus gazella'}, 'Afrosoricida': {
**********
No errors.
======================================================================
Script: cfexercises2.py

Contents:

**********

########################
def hello_1(x):
    for j in range(x):
        if j % 3 == 0:
            print('hello')
    print(' ')

hello_1(12)

########################
def hello_2(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')
    print(' ')

hello_2(12)

########################
def hello_3(x, y):
    for i in range(x, y):
        print('hello')
    print(' ')

hello_3(3, 17)

########################
def hello_4(x):
    while x != 15:
        print('hello')
        x = x + 3
    print(' ')

hello_4(0)

########################
def hello_5(x):
    while x < 100:
        if x == 31:
            for k in range(7):
                print('hello')
        elif x == 18:
            print('hello')
        x = x + 1
    print(' ')

hello_5(12)

# WHILE loop with BREAK
def hello_6(x, y):
    while x: # while x is True
        print("hello! " + str(y))
        y += 1 # increment y by 1 
        if y == 6:
            break
    print(' ')

hello_6 (True, 0)
**********

Output (first 500 chars):

**********
hello
hello
hello
hello
 
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
 
hello! 0
hello! 1
hello! 2
hello! 3
hello! 4
hello! 5
 

**********
No errors.
======================================================================
Script: using_name.py

Contents:

**********
#!/usr/bin/env python3
# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself!')
else:
    print('I am being imported from another script/program/module!')

print("This module's name is: " + __name__)
**********

Output (first 500 chars):

**********
This program is being run by itself!
This module's name is: __main__

**********
No errors.
======================================================================
Script: basic_io3.py

Contents:

**********
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)

**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ShuqingRen_sr1822/week2/code/basic_io3.py", line 9, in <module>
    f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

**********
======================================================================
Script: scope.py

Contents:

**********
## variables & function

_a_global = 10 # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5 # also a global variable
    
print("Before calling a_function, outside the function, the value of _a_global is", _a_global)
print("Before calling a_function, outside the function, the value of _b_global is", _b_global)

def a_function():
    _a_global = 4 # a local variable
    
    if _a_global >= 4:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 3
    
    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value of _b_global is", _b_global)
    print("Inside the function, the value of _a_local is", _a_local)
    
a_function()

print("After calling a_function, outside the function, the value of _a_global is (still)", _a_global)
print("After calling a_function, outside the function, the value of _b_global is (still)", _b_global)
print("After calling a_function, outside the function, the value of _a_local is ", _a_local)


## global variable & function
_a_global = 10

def a_function():

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is", _a_global)

    _a_function2()
    
    print("After calling a_function2, value of _a_global is", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is", _a_global)

## another example of global veriable
def a_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is", _a_global)

    _a_function2()
    
    print("After calling a_function2, value of _a_global is", _a_global)
    
a_function()

print("The value of a_global in main workspace / namespace now is", _a_global)
**********

Output (first 500 chars):

**********
Before calling a_function, outside the function, the value of _a_global is 10
Before calling a_function, outside the function, the value of _b_global is 15
Inside the function, the value of _a_global is 4
Inside the function, the value of _b_global is 9
Inside the function, the value of _a_local is 3
After calling a_function, outside the function, the value of _a_global is (still) 10
After calling a_function, outside the function, the value of _b_global is (still) 15

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ShuqingRen_sr1822/week2/code/scope.py", line 27, in <module>
    print("After calling a_function, outside the function, the value of _a_local is ", _a_local)
                                                                                       ^^^^^^^^
NameError: name '_a_local' is not defined. Did you mean: '_a_global'?

**********
======================================================================
Script: basic_io1.py

Contents:

**********
#############################
# FILE INPUT
#############################
# Open a file for reading ('r')
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()

**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ShuqingRen_sr1822/week2/code/basic_io1.py", line 5, in <module>
    f = open('../sandbox/test.txt', 'r')
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

**********
======================================================================
Script: cfexercises1.py

Contents:

**********
#!/user/bin/env python3

"""2/4 of CMEE week2 coursework (control flow)"""
__author__ = "Shuqing Ren"
__version__ = "0.0.1"

import sys

def foo_1(x=9):
    """Find the square root of input"""
    sqr_x = x ** 0.5    # (= x^0.5)
    return f"The square root of {x} is {sqr_x}."

def foo_2(x=7, y=0):
    """Compare the value of a pair of numbers."""
    if x > y:
        return f"{x} is larger than {y}."
    elif x == y:
        return f"{x} is equal to {y}."
    return f"{y}is larger than {x}."

def foo_3(x=5, y=3, z=8):
    """Sort a list from the smallest to largest"""
    if x > y:
        x, y = y, x
    if x > z:
        x, z = z, x
    if y > z:
        y, z = z, y
    a_list = [x, y, z]
    return f"From the smallest to largest: {a_list}"

def foo_4(x=2):
    """Calculate the factorial of x."""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return f"The factorial of {x} is {result}."

def foo_5(x=6): # a recursive function that calculates the factorial of x
    """Recursively calculate the factorial of x."""
    if x == 1 or x == 0:   # modify to also return result for 0
        return 1
    return x * foo_5(x - 1)
# !: can't find a way to print final the result, no return message for this
     
def foo_6(x=4):  # Calculate the factorial of x in a different way
    """Calculate the factorial of x without if statement."""
    facto = 1
    x_loop = x   # copy x to another variable for looping control, so x remains unchanged
    while x_loop >= 1:
        facto = facto * x_loop
        x_loop = x_loop - 1
    return f"The factorial of {x} is {facto}."

def main(argv):
    print(foo_1())
    print(foo_2())
    print(foo_3())
    print(foo_4())
    print(f"The factorial of 6 is {foo_5()}.")
    print(foo_6())
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
The square root of 9 is 3.0.
7 is larger than 0.
From the smallest to largest: [3, 5, 8]
The factorial of 2 is 2.
The factorial of 6 is 720.
The factorial of 4 is 24.

**********
No errors.
======================================================================
Script: control_Flow.py

Contents:

**********
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__author__ = 'Samraat Pawar (s.pawar@imperial.ac.uk)'
__version__ = '0.0.1'

import sys

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return f"No divisor found for {x}!" # Each function can return a value or a variable.
    return f"The largest divisor of {x} is {largest}"

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            print(f"{x} is not a prime: {i} is a divisor") 
            return False
    print(f"{x} is a prime!")
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print(f"There are {len(allprimes)} primes between 2 and {x}")
    return allprimes
      
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is
**********
No errors.
======================================================================
Script: debugme.py

Contents:

**********
def buggyfunc(x):
    y = x
    for i in range(x):
        try:
            y = y-1
            z = x/y
        except:
            print(f"This didn't work;{x = }; {y = }")
    return z

buggyfunc(20)
**********

Output (first 500 chars):

**********
This didn't work;x = 20; y = 0

**********
No errors.
======================================================================
Script: boilerplate.py

Contents:

**********
#!/usr/bin/env python3

"""Description of this program or application.
You can use several lines"""

__appname__ = '[application name here]'
__author__ = 'Your Name (your@email.address)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
    # sys.exit("I am exiting right now!")
    # text were printed,
    # IDE note: An exception has occurred, use %tb to see the full traceback.
**********

Output (first 500 chars):

**********
This is a boilerplate

**********
No errors.
======================================================================
Script: basic_io2.py

Contents:

**********
#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ShuqingRen_sr1822/week2/code/basic_io2.py", line 7, in <module>
    f = open('../sandbox/testout.txt','w')
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testout.txt'

**********
======================================================================
Script: lc1.py

Contents:

**********
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

birds_latin = [species[0]                    # select the wanted element of inner tuple
               for species in birds]         # loop over the outer tuple (species)

birds_common = [species[1]
                for species in birds]

birds_mass = [species[2]
              for species in birds]

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

latin_cl = []                   # empty list for storage
for species in birds:           # loop over the outer tuple
    latin_cl.append(species[0]) # append the wanted element of inner tuple

common_cl = []
for species in birds:
    common_cl.append(species[1])

mass_cl = []
for species in birds:
    mass_cl.append(species[2])

# A nice example out out is:
# Step #1:
# Latin names:
# ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
# ... etc.
 
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: sysargv.py

Contents:

**********
#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))
**********

Output (first 500 chars):

**********
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********
No errors.
======================================================================
Script: oaks_debugme.py

Contents:

**********
import csv
import sys

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus'.
    
    >>> is_an_oak('Fagus sylvatica')
    False
    
    >>> is_an_oak('Quercus robur')
    True

    >>> is_an_oak('Quercuss')
    False
    
    """
    # Modify to if loop to chacke the exact match.
    if name.lower() == 'quercus':  # fixed typo, original: quercs
        return True
    else:
        return False

def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../results/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)    # add exit
**********

Output (first 500 chars):

**********
['Genus', ' species']
The genus is: 
Genus

['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********
No errors.
======================================================================
Script: tuple.py

Contents:

**********
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by
# species 
# 
# A nice example output is:
# 
# Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
# ... etc.

for species in birds:                       # loop over by species(the outer tuple)
    print("Latin name: " + species[0] +     # print elements one by one
          "; Common name: " + species[1] + 
          "; Mass: " + str(species[2]))     # only same type can be concatenated

**********

Output (first 500 chars):

**********
Latin name: Passerculus sandwichensis; Common name: Savannah sparrow; Mass: 18.7
Latin name: Delichon urbica; Common name: House martin; Mass: 19
Latin name: Junco phaeonotus; Common name: Yellow-eyed junco; Mass: 19.5
Latin name: Junco hyemalis; Common name: Dark-eyed junco; Mass: 19.6
Latin name: Tachycineata bicolor; Common name: Tree swallow; Mass: 20.2

**********
No errors.
======================================================================
Script: test_control_flow.py

Contents:

**********
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""

__author__ = 'Shuqing Ren (sr1822@ic.ac.uk)'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
        
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    
    """
    #Define function to be tested
    if x % 2 == 0:
        return f"{x} is Even!"
    return f"{x} is Odd!"

def main(argv): 
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()   # To run with embedded tests
**********

Output (first 500 chars):

**********
22 is Even!
33 is Odd!

**********
No errors.
======================================================================
Script: loops.py

Contents:

**********
# FOR loops
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loop
z = 0
while z < 100:
    z = z + 1
    print(z)
**********

Output (first 500 chars):

**********
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********
No errors.
======================================================================
Script: basic_csv.py

Contents:

**********
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
with open('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f)
    temp = []
    for row in csvread:
        temp.append(tuple(row))
        print(row)
        print("The species is", row[0])

# write a file containing only species name and Body mass
with open('../data/testcsv.csv','r') as f:
    with open('../data/bodymass.csv','w') as g:

        csvread = csv.reader(f)
        csvwrite = csv.writer(g)
        for row in csvread:
            print(row)
            csvwrite.writerow([row[0], row[4]])

**********

Output (first 500 chars):

**********
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagas
**********
No errors.
======================================================================
Script: align_seqs.py

Contents:

**********
#!/user/bin/env python3

"""3/4 of CMEE week2 coursework (sequence alignment)"""
__author__ = "Shuqing Ren"
__version__ = "0.0.1"

import sys

# extract sequences from external file to a list
seq = []
with open("../data/SampleSeq.fasta","r") as s:
    for line in s:
        if line[0] != ">":
            seq.append(line.strip())

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
l1 = len(seq[0])
l2 = len(seq[1])
if l1 >= l2:
    s1 = seq[0]
    s2 = seq[1]
else:
    s1 = seq[1]
    s2 = seq[0]
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                score = score + 1
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

# save the output to a text file
with open("../results/aligned_seqs.txt", "w") as out:
    print(my_best_align, file = out)
    print(s1, file = out)
    print("Best score:", my_best_score, file = out)

def main(argv):
    print("Run as main")
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********

Output (first 500 chars):

**********
Run as main

**********
No errors.
======================================================================
Script: break.R

Contents:

**********
# to break out of a loop when some condition is met,
# use break in situations when you cannot set a target number 
# of iterations and would like to stop the loop execultion 
# once some condition is met 

i <- 0 #Initialize i
    while (i < Inf) {
        if (i == 10) {
            break 
        } else { # Break out of the while loop!  
            cat("i equals " , i , " \n")
            i <- i + 1 # Update i
    }
}
**********

Output (first 500 chars):

**********
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********
No errors.
======================================================================
Script: sample.R

Contents:

**********
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n) {
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample))
}

## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num) {
    result1 <- vector() #Initialize empty vector of size 1 
    for(i in 1:num) {
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(,num) #Preallocate expected size
    for(i in 1:num) {
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
    result3 <- vector("list", num) #Preallocate expected size
    for(i in 1:num) {
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

######### Generate a population ##########
set.seed(12345)
popn <- rnorm(10000) # Generate the population
p <- hist(popn)

######### Run & time ##########
n <- 100 # sample size for each experiment
num <- 10000 # Number of times to rerun the experiment

print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))
**********

Output (first 500 chars):

**********
[1] "Using loops without preallocation on a vector took:"
   user  system elapsed 
  0.281   0.031   0.318 
[1] "Using loops with preallocation on a vector took:"
   user  system elapsed 
  0.147   0.001   0.149 
[1] "Using loops with preallocation on a list took:"
   user  system elapsed 
  0.147   0.000   0.148 
[1] "Using the vectorized sapply function (on a list) took:"
   user  system elapsed 
  0.163   0.000   0.163 
[1] "Using the vectorized lapply function (on a list) took:"
   user  sys
**********
No errors.
======================================================================
Script: Vectorize1.R

Contents:

**********
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M) {
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]) {
    for (j in 1:Dimensions[2]) {
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}
 
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********

Output (first 500 chars):

**********
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.038   0.001   0.039 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.001   0.000   0.001 

**********
No errors.
======================================================================
Script: R_conditionals.R

Contents:

**********
# Functions with conditionals

### Example 1
# Checks if an integer is even
is.even <- function(n = 2) {
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
  return(paste(n,'is odd!'))
  }
}

is.even(6)

### Example 2
# Checks if a number is a power of 2
is.power2 <- function(n = 2) {
  if (log2(n) %% 1==0) {
    return(paste(n, 'is a power of 2!'))
  } else {
  return(paste(n,'is not a power of 2!'))
    }
}

is.power2(4)

### Example 3
# Checks if a number is prime
is.prime <- function(n) {
  if (n==0) {
    return(paste(n,'is a zero!'))
  } else if (n==1) {
    return(paste(n,'is just a unit!'))
  }
    
  ints <- 2:(n-1)
  
  if (all(n%%ints!=0)) {
    return(paste(n,'is a prime!'))
  } else {
  return(paste(n,'is a composite!'))
    }
}

is.prime(3)
**********

Output (first 500 chars):

**********
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********
No errors.
======================================================================
Script: apply1.R

Contents:

**********
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********

Output (first 500 chars):

**********
 [1]  0.18832947 -0.12165375  0.12123287 -0.30997652  0.07914184 -0.18102229
 [7] -0.04984912 -0.26300178  0.37849961  0.01860613
 [1] 1.0807327 1.0123729 2.0031066 0.5524050 0.6937721 1.7725840 0.7589947
 [8] 0.8794467 0.4458377 1.2317536
 [1]  0.17191887 -0.02706886  0.01637249 -0.24883707 -0.57601814  0.19832658
 [7] -0.01774783 -0.09707918  0.07400755  0.36643204

**********
No errors.
======================================================================
Script: basic_io.R

Contents:

**********
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

**********
======================================================================
Script: Florida.R

Contents:

**********
# Is Florida getting warmer?

# Calculate the correlation coefficients (temperature & time).
## Can’t use standard p-value calculated for a correlation coefficient
## since data are not independent.
# Use a permutation analysis instead, by generating 
# a distribution of random correlation coefficients and compare 
# your observed coefficient with this random distribution.

# load & check data
rm(list=ls())   # clear workspace
load("../data/KeyWestAnnualMeanTemperature.RData") 
ls()    # check loading
class(ats)
head(ats)
plot(ats)

# corelation coefficient


**********

Output (first 500 chars):

**********
[1] "ats"
[1] "data.frame"
  Year     Temp
1 1901 23.75000
2 1902 24.66667
3 1903 24.71667
4 1904 24.51667
5 1905 24.88333
6 1906 24.63333

**********
No errors.
======================================================================
Script: boilerplate.R

Contents:

**********
# A boilerplate R script

MyFunction <- function(Arg1, Arg2) {
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
    
  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********

Output (first 500 chars):

**********
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********
No errors.
======================================================================
Script: apply2.R

Contents:

**********
SomeOperation <- function(v) { # (What does this function do?)
  if (sum(v) > 0) { #note that sum(v) is a single (scalar) value
    return (v * 100)
  } else { 
  return (v)
    }
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********

Output (first 500 chars):

**********
             [,1]       [,2]          [,3]       [,4]       [,5]       [,6]
 [1,] -1.00635780  205.49010  0.2975855418 -0.4947016   50.02691 -1.3002459
 [2,] -2.18608678 -153.65863  0.0175822001 -1.5516130  233.19847 -0.6880960
 [3,] -1.08945126   88.86910  0.5214318255  1.1495941  -46.46202  0.6344655
 [4,]  0.34218974 -114.42242 -0.2314700657 -0.6925876  -52.78801 -0.2462841
 [5,]  0.57974188   28.36975  0.1540441114 -0.1400338   84.19090 -0.3698395
 [6,] -0.48721966  -10.02105 -1.0114267956  
**********
No errors.
======================================================================
Script: try.R

Contents:

**********
# sample & mean
doit <- function(x) {
    temp_x <- sample(x, replace = TRUE)
    if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
         print(paste("Mean of this sample was:", as.character(mean(temp_x))))
        } 
    else {
        stop("Couldn't calculate mean: too few unique values!")
        }
    }

# generate a population
set.seed(1345) # to get the same result for illustration
popn <- rnorm(50)
hist(popn)

# execution
# lapply(1:15, function(i) doit(popn))  # likely stop at a point
result <- lapply(1:15, function(i) try(doit(popn), FALSE))
# The FALSE modifier for the try command suppresses any error messages, 
# but result will still contain them so that you can inspect them later

# running results & errors stored in the object "result"
class(result)

# another manual way of storing of results
result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
    }
**********

Output (first 500 chars):

**********
[1] "Mean of this sample was: -0.11620822588674"
[1] "Mean of this sample was: -0.0468516755995931"
[1] "Mean of this sample was: -0.0890228211466614"
[1] "Mean of this sample was: -0.124229742255296"
[1] "Mean of this sample was: 0.0314144452816157"
[1] "Mean of this sample was: -0.233476945796405"
[1] "Mean of this sample was: -0.196681538928001"
[1] "Mean of this sample was: 0.0146969612111605"
[1] "Mean of this sample was: -0.234913159471725"
[1] "Mean of this sample was: -0.0497464588165691
**********
Errors:
**********
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!

**********
======================================================================
Script: control_flow.R

Contents:

**********
# if statement
### Example 1
a <- TRUE
if (a == TRUE) {
    print ("a is TRUE")
} else {
    print ("a is FALSE")
}
### Example 2
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}

# for loop
### Example 1
for (i in 1:10) {
    j <- i * i
    print(paste(i, " squared is", j ))
}
### Example 2
for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
      print(paste('The species is', species))
}
### Example 3
v1 <- c("a","bc","def") # use existing vector
for (i in v1) {
    print(i)
}

# while loop
### Example 1
i <- 0
while (i < 10) {
    i <- i+1
    print(i^2)
}
**********

Output (first 500 chars):

**********
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********
No errors.
======================================================================
Script: TreeHeight.R

Contents:

**********
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeHeight <- function(degrees, distance) { # given cal function
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
  
    return (height)
}


trees <- read.csv("../data/trees.csv")  # read in data

Height.m <- TreeHeight(trees$Angle.degrees, trees$Distance.m)   # calculate
treesH <- data.frame(trees, Height.m)  # combine data

write.csv(treesH, "../results/TreeHts.csv") # write out results
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: next.R

Contents:

**********
# skip to next iteration of a loop. 
# Both next and break can be used within other loops 
# (while, for)

for (i in 1:10) {
  if ((i %% 2) == 0) # check if the number is odd
    next # pass to next iteration of loop 
  print(i)
}
**********

Output (first 500 chars):

**********
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********
No errors.
======================================================================
Script: browse.R

Contents:

**********
Exponential <- function(N0 = 1, r = 1, generations = 10) {
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations) {
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********

Output (first 500 chars):

**********
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********
No errors.
======================================================================
Script: preallocate.R

Contents:

**********
NoPreallocFun <- function(x) {
    a <- vector() # empty vector
    for (i in 1:x) {
        a <- c(a, i) # concatenate
    }
}

system.time(NoPreallocFun(1000))



PreallocFun <- function(x) {
    a <- rep(NA, x) # pre-allocated vector
    for (i in 1:x) {
        a[i] <- i # assign
    }
}

system.time(PreallocFun(1000))
**********

Output (first 500 chars):

**********
   user  system elapsed 
  0.008   0.001   0.010 
   user  system elapsed 
  0.002   0.000   0.002 

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 50
Scripts successful: 42
Scripts with errors: 8
Warnings/Notes: 2

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

